<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><style type="text/css">/* Copyright 2019 Google LLC                              */
/*                                                        */
/* Use of this source code is governed by a BSD-style     */
/* license that can be found in the LICENSE file or at    */
/* https://developers.google.com/open-source/licenses/bsd */

body {
  font-family: Helvetica, sans-serif;
  font-size: 100%;
  color: #333;
  display: flex;
  justify-content: space-between;
  overflow-x: hidden;

  --main-width: 50rem;
  --nav-width: 20rem;
}

@media (max-width: 70rem) {
    /*For narrow screens hide nav and enable horizontal scrolling */
    nav {display: none;}
    body {overflow-x: auto;}
}

nav {/* this actually just holds space for #navbar, which is fixed */
  min-width: var(--nav-width);
  max-width: var(--nav-width);
}
#navbar {
  position: fixed;
  height: 100vh;
  width: var(--nav-width);
  overflow-y: scroll;
  border-right: 1px solid firebrick;
}
#navbar:before {
  content: "Contents";
  font-weight: bold;
}
nav ol {
  list-style-type:none;
  padding-left: 1rem;
}

#main-output {
  max-width: var(--main-width);
  margin: auto;
}

.cell {
}

.code-block, .err-block, .result-block {
  padding: 0em 0em 0em 2em;
  display: block;
  font-family: monospace;
  white-space: pre;
}

code {
  background-color: #F0F0F0;
}

.result-block {
  border-left: 3px solid  #87CEFA;
}

.prose-block {
  line-height: 140%;
}

.err-block {
  font-weight: bold;
  color: #B22222;
  border-left: 3px solid #B22222;
}

.plot {
  padding: 5em;
}

.plot-img {
  width: 80%;
}

.comment {
  color: #808080;
}

.keyword {
  color: #0000DD;
}

.command {
  color: #A80000;
}

.symbol {
  color: #E07000;
}

.type-name {
  color: #A80000;
}

.iso-sugar {
  color: #25BBA7;
}
</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script><script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" onload="// Copyright 2019 Google LLC
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

var katexOptions = {
    delimiters: [
        {left: &quot;$$&quot;, right: &quot;$$&quot;, display: true},
        {left: &quot;\\[&quot;, right: &quot;\\]&quot;, display: true},
        {left: &quot;$&quot;, right: &quot;$&quot;, display: false},
        {left: &quot;\\(&quot;, right: &quot;\\)&quot;, display: false}
    ],
    // Enable commands that load resources or change HTML attributes
    // (e.g. hyperlinks): https://katex.org/docs/security.html.
    trust: true
};

var cells = {};

function append_contents(key, contents) {
    if (key in cells) {
        var cur_cells = cells[key];
    } else {
        var cell = document.createElement(&quot;div&quot;);
        cell.className = &quot;cell&quot;;
        cells[key] = [cell];
        var cur_cells = [cell];
    }
    for (var i = 0; i &lt; contents.length; i++) {
        for (var j = 0; j &lt; cur_cells.length; j++) {
            var node = lookup_address(cur_cells[j], contents[i][0])
            node.innerHTML += contents[i][1];
        }
    }
}

function lookup_address(cell, address) {
    var node = cell
    for (i = 0; i &lt; address.length; i++) {
        node = node.children[address[i]]
    }
    return node
}

function renderLaTeX() {
    // Render LaTeX equations in prose blocks via KaTeX.
    var proseBlocks = document.querySelectorAll(&quot;.prose-block&quot;);
    Array.from(proseBlocks).map((proseBlock) =&gt;
        renderMathInElement(proseBlock, katexOptions)
    );
}

/**
 * Rendering the Table of Contents / Navigation Bar
 * 2 key functions
 *  - `updateNavigation()` which inserts/updates the navigation bar
 *  - and it&#39;s helper `extractStructure()` which extracts the structure of the page
 *    and adds ids to heading elements.
*/
function updateNavigation() {
    function navItemList(struct) {
        var listEle = document.createElement(&#39;ol&#39;)
        struct.children.forEach(childStruct=&gt;
            listEle.appendChild(navItem(childStruct))
        );
        return listEle;
    }
    function navItem(struct) {
        var a = document.createElement(&#39;a&#39;);
        a.appendChild(document.createTextNode(struct.text));
        a.title = struct.text;
        a.href = &quot;#&quot;+struct.id;

        var ele = document.createElement(&#39;li&#39;)
        ele.appendChild(a)
        ele.appendChild(navItemList(struct));
        return ele;
    }

    var navbarEle = document.getElementById(&quot;navbar&quot;)
    if (navbarEle === null) {  // create it
        navbarEle = document.createElement(&quot;div&quot;);
        navbarEle.id=&quot;navbar&quot;;
        navOuterEle = document.createElement(&quot;nav&quot;)
        navOuterEle.appendChild(navbarEle);
        document.body.prepend(navOuterEle);
    }

    navbarEle.innerHTML = &quot;&quot;
    var structure = extractStructure()
    navbarEle.appendChild(navItemList(structure));
}

function extractStructure() { // Also sets ids on h1,h2,...
    var headingsNodes = document.querySelectorAll(&quot;h1, h2, h3, h4, h5, h6&quot;);
    // For now we are just fulling going to regenerate the structure each time
    // Might be better if we made minimal changes, but ð¤·

    // Extract the structure of the document
    var structure = {children:[]}
    var active = [structure.children];
    headingsNodes.forEach(
        function(currentValue, currentIndex) {
            currentValue.id = &quot;s-&quot; + currentIndex;
            var currentLevel = parseInt(currentValue.nodeName[1]);

            // Insert dummy levels up for any levels that are skipped
            for (var i=active.length; i &lt; currentLevel; i++) {
                var dummy = {id: &quot;&quot;, text: &quot;&quot;, children: []}
                active.push(dummy.children);
                var parentList = active[i-1]
                parentList.push(dummy);
            }
            // delete this level and everything after
            active.splice(currentLevel, active.length);

            var currentStructure = {
                id: currentValue.id,
                text: currentValue.textContent,
                children: [],
            };
            active.push(currentStructure.children);

            var parentList = active[active.length-2]
            parentList.push(currentStructure);
        },
    );
    return structure;
}

/**
 * HTML rendering mode.
 * Static rendering is used for static HTML pages.
 * Dynamic rendering is used for dynamic HTML pages via `dex web`.
 *
 * @enum {string}
 */
var RENDER_MODE = Object.freeze({
  STATIC: &quot;static&quot;,
  DYNAMIC: &quot;dynamic&quot;,
})

/**
 * Renders the webpage.
 * @param {RENDER_MODE} renderMode The render mode, either static or dynamic.
 */
function render(renderMode) {
    if (renderMode == RENDER_MODE.STATIC) {
        // For static pages, simply call rendering functions once.
        renderLaTeX();
        updateNavigation();
    } else {
        // For dynamic pages (via `dex web`), listen to update events.
        var source = new EventSource(&quot;/getnext&quot;);
        source.onmessage = function(event) {
            var body = document.getElementById(&quot;main-output&quot;);
            var msg = JSON.parse(event.data);
            if (msg == &quot;start&quot;) {
                body.innerHTML = &quot;&quot;;
                cells = {}
                return
            }
            var order    = msg[0];
            var contents = msg[1];
            for (var i = 0; i &lt; contents.length; i++) {
                append_contents(contents[i][0], contents[i][1]);
            }
            if (order != null) {
                var new_cells = {};
                body.innerHTML = &quot;&quot;;
                for (var i = 0; i &lt; order.val.length; i++) {
                    var key = order.val[i]
                    var cur_cells = cells[key]
                    if (cur_cells.length == 0) {
                        var cur_cell = new_cells[key][0].cloneNode(true)
                    } else {
                        var cur_cell = cur_cells.pop()
                        if (key in new_cells) {
                            new_cells[key].push(cur_cell);
                        } else {
                            new_cells[key] = [cur_cell];
                        }
                    }
                    body.appendChild(cur_cell);
                }
                Object.assign(cells, new_cells);
            }
            renderLaTeX();
            updateNavigation();
        };
    }
}
render(RENDER_MODE.STATIC);"></script></head><body><div id="main-output"><div class="cell"><div class="prose-block"><h2>Connectionist Temporal Classification</h2>
<p>By Alex Graves et alia.</p>
</div></div><div class="cell"><div class="prose-block"><p><a href="https://www.cs.toronto.edu/%7Egraves/icml_2006.pdf">Link to paper</a>.</p>
</div></div><div class="cell"><div class="prose-block"><p>This dynamic programming algorithm computes the probability of a particular sequences of labels
(without pauses included) given another sequence of label probabilities
(with pauses included), marginalizing over all possible combination of
pause lengths.
It's used for training speech-to-text models on unaligned training data.</p>
</div></div><div class="cell"><div class="prose-block"><p>Most implementations of CTC compute the marginal logprob
and its gradients combining a forward and a backward pass.
However, as mentioned in the original paper, we should only
need the last step of the forward pass to compute the marginal
probability, and Dex's autodiff should produce the backward
pass automatically.  That makes this code much shorter than
most implementations.</p>
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> interleave (blank<span class="command">:v</span>) (labels<span class="symbol">:</span> m<span class="symbol">=&gt;</span>v) <span class="symbol">:</span> (m <span class="symbol">&amp;</span> (<span class="type-name">Fin</span> 2))<span class="symbol">=&gt;</span>v <span class="symbol">=</span>
  <span class="comment">-- Turns &quot;text&quot; into &quot;t e x t &quot; by first pairing each letter with a blank,
</span>  <span class="comment">-- then flattening the pairs back into a single-index table.
</span>  pairs <span class="symbol">=</span> <span class="keyword">for</span> i<span class="symbol">.</span> [labels<span class="symbol">.</span>i<span class="symbol">,</span> blank]
  <span class="keyword">for</span> (i<span class="symbol">,</span> j)<span class="symbol">.</span> pairs<span class="symbol">.</span>i<span class="symbol">.</span>j
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> prepend (first<span class="symbol">:</span> v) (seq<span class="symbol">:</span> m<span class="symbol">=&gt;</span>v) <span class="symbol">:</span> ({head<span class="symbol">:</span><span class="type-name">Unit</span> <span class="symbol">|</span> tail<span class="command">:m</span> }<span class="symbol">=&gt;</span>v) <span class="symbol">=</span>
  <span class="comment">-- Concatenates a single element to the beginning of a sequence.
</span>  <span class="keyword">for</span> idx<span class="symbol">.</span> <span class="keyword">case</span> idx <span class="keyword">of</span>
    {<span class="symbol">|</span> head <span class="symbol">=</span> () <span class="symbol">|</span>} <span class="symbol">-&gt;</span> first
    {<span class="symbol">|</span> tail <span class="symbol">=</span> i  <span class="symbol">|</span>} <span class="symbol">-&gt;</span> seq<span class="symbol">.</span>i
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> prepend_and_interleave (blank<span class="command">:v</span>) (seq<span class="symbol">:</span> m<span class="symbol">=&gt;</span>v) <span class="symbol">:</span>
  ({head<span class="symbol">:</span><span class="type-name">Unit</span> <span class="symbol">|</span> tail<span class="symbol">:</span>(m <span class="symbol">&amp;</span> (<span class="type-name">Fin</span> 2))}<span class="symbol">=&gt;</span>v) <span class="symbol">=</span>
  <span class="comment">-- Turns &quot;text&quot; into &quot; t e x t&quot;.
</span>  <span class="comment">-- The output of this function has a slightly complicated output type, which
</span>  <span class="comment">-- has size 1 + 2 * (size m).
</span>  interleaved <span class="symbol">=</span> interleave blank seq
  prepend blank interleaved
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> clipidx (n<span class="symbol">:</span><span class="type-name">Type</span>) <span class="symbol">-&gt;</span> (i<span class="symbol">:</span><span class="type-name">Int</span>) <span class="symbol">:</span> n <span class="symbol">=</span>
  <span class="comment">-- Returns element at 0 if less than zero.
</span>  <span class="comment">-- Ideally we could have an alternative
</span>  <span class="comment">-- to Fin that just clips the index at its bounds.
</span>  fromOrdinal n (select (i <span class="symbol">&lt;</span> 0) 0 i)
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> logaddexp (x<span class="symbol">:</span><span class="type-name">Float</span>) (y<span class="symbol">:</span><span class="type-name">Float</span>) <span class="symbol">:</span> <span class="type-name">Float</span> <span class="symbol">=</span>
  m <span class="symbol">=</span> max x y
  m <span class="symbol">+</span> ( log ( (exp (x <span class="symbol">-</span> m) <span class="symbol">+</span> exp (y <span class="symbol">-</span> m))))
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> ctc [<span class="type-name">Eq</span> vocab<span class="symbol">,</span> <span class="type-name">Eq</span> position<span class="symbol">,</span> <span class="type-name">Eq</span> time]
        (blank<span class="symbol">:</span>  vocab)
        (logits<span class="symbol">:</span> time<span class="symbol">=&gt;</span>vocab<span class="symbol">=&gt;</span><span class="type-name">Float</span>)
        (labels<span class="symbol">:</span> position<span class="symbol">=&gt;</span>vocab)
        <span class="symbol">:</span> <span class="type-name">Float</span> <span class="symbol">=</span>
  <span class="comment">-- Computes log p(labels | logits), marginalizing over possible alignments.
</span>  <span class="comment">-- Todo: remove unnecessary implicit type annotations once
</span>  <span class="comment">-- Dex starts putting implicit types in scope.
</span>
  ilabels <span class="symbol">=</span> prepend_and_interleave blank labels

  normalized_logits <span class="symbol">=</span> <span class="keyword">for</span> t<span class="symbol">.</span> logsoftmax logits<span class="symbol">.</span>t

  <span class="comment">-- Initialization rules
</span>  logprob_start_with_blank <span class="symbol">=</span> normalized_logits<span class="symbol">.</span>(0<span class="symbol">@</span>_)<span class="symbol">.</span>blank
  logprob_<span class="keyword">of</span>_first_label   <span class="symbol">=</span> normalized_logits<span class="symbol">.</span>(0<span class="symbol">@</span>_)<span class="symbol">.</span>(labels<span class="symbol">.</span>(0<span class="symbol">@</span>_))
  log_prob_seq_t0 <span class="symbol">=</span> <span class="keyword">for</span> pos<span class="symbol">.</span>
    <span class="comment">-- TODO: allow pattern-matching on integer literals
</span>    <span class="keyword">case</span> ordinal pos <span class="symbol">==</span> 0 <span class="keyword">of</span>
      <span class="type-name">True</span> <span class="symbol">-&gt;</span> logprob_start_with_blank
      <span class="type-name">False</span> <span class="symbol">-&gt;</span> <span class="keyword">case</span> ordinal pos <span class="symbol">==</span> 1 <span class="keyword">of</span>
        <span class="type-name">True</span>  <span class="symbol">-&gt;</span> logprob_<span class="keyword">of</span>_first_label
        <span class="type-name">False</span> <span class="symbol">-&gt;</span> log 0<span class="symbol">.</span>000001

  same_as_last <span class="symbol">=</span> <span class="symbol">\</span>ilabels s<span class="symbol">.</span>
    o <span class="symbol">=</span> ordinal s
    select (o <span class="symbol">&gt;=</span> 2) (ilabels<span class="symbol">.</span>s <span class="symbol">==</span> ilabels<span class="symbol">.</span>(clipidx _ (o <span class="symbol">-</span> 2))) <span class="type-name">False</span>

  safe_idx <span class="symbol">=</span> <span class="symbol">\</span>prev s<span class="symbol">.</span>
    select (s <span class="symbol">&gt;=</span> 0) prev<span class="symbol">.</span>(clipidx _ s) (log 0<span class="symbol">.</span>0)

  <span class="comment">-- Todo: As suggested by Adam Paske, we could get rid of these
</span>  <span class="comment">-- logaddexp calls with a newtype that overloads + and *
</span>  update <span class="symbol">=</span> <span class="symbol">\</span>t prev<span class="symbol">.</span>
    <span class="keyword">case</span> ordinal t <span class="symbol">==</span> 0 <span class="keyword">of</span>
      <span class="type-name">True</span> <span class="symbol">-&gt;</span> log_prob_seq_t0
      <span class="type-name">False</span> <span class="symbol">-&gt;</span> <span class="keyword">for</span> s<span class="symbol">.</span>
        cond <span class="symbol">=</span> ilabels<span class="symbol">.</span>s <span class="symbol">==</span> blank <span class="symbol">||</span> same_as_last ilabels s
        labar <span class="symbol">=</span> logaddexp prev<span class="symbol">.</span>s (safe_idx prev ((ordinal s) <span class="symbol">-</span> 1))
        other <span class="symbol">=</span> logaddexp labar  (safe_idx prev ((ordinal s) <span class="symbol">-</span> 2))
        ans <span class="symbol">=</span> select cond labar other
        ans <span class="symbol">+</span> normalized_logits<span class="symbol">.</span>t<span class="symbol">.</span>(ilabels<span class="symbol">.</span>s)

  log_prob_seq_final <span class="symbol">=</span> fold log_prob_seq_t0 update

  <span class="comment">-- Todo: nicer way to get last two elements of log_prob_seq_final.
</span>  seq_length <span class="symbol">=</span> 1 <span class="symbol">+</span> size (position <span class="symbol">&amp;</span> (<span class="type-name">Fin</span> 2))
  endlabel <span class="symbol">=</span> log_prob_seq_final<span class="symbol">.</span>((seq_length <span class="symbol">-</span> 2)<span class="symbol">@</span>_)
  endspace <span class="symbol">=</span> log_prob_seq_final<span class="symbol">.</span>((seq_length <span class="symbol">-</span> 1)<span class="symbol">@</span>_)
  logaddexp endlabel endspace
</div></div><div class="cell"><div class="code-block">

</div></div><div class="cell"><div class="prose-block"><h3>Demo</h3>
</div></div><div class="cell"><div class="code-block"><span class="keyword">def</span> randIdxNoZero (n<span class="symbol">:</span><span class="type-name">Type</span>) <span class="symbol">-&gt;</span> (k<span class="symbol">:</span><span class="type-name">Key</span>) <span class="symbol">:</span> n <span class="symbol">=</span>
  unif <span class="symbol">=</span> rand k
  fromOrdinal n <span class="symbol">$</span> (1 <span class="symbol">+</span> (<span class="type-name">FToI</span> (floor ( unif <span class="symbol">*</span> <span class="type-name">IToF</span> ((size n) <span class="symbol">-</span> 1)))))
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="type-name">Vocab</span> <span class="symbol">=</span> <span class="type-name">Fin</span> 6
</div></div><div class="cell"><div class="code-block">position <span class="symbol">=</span> <span class="type-name">Fin</span> 3
</div></div><div class="cell"><div class="code-block">blank <span class="symbol">=</span> 0<span class="symbol">@</span><span class="type-name">Vocab</span>
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Create random logits
</span></div></div><div class="cell"><div class="code-block"><span class="type-name">Time</span> <span class="symbol">=</span> <span class="type-name">Fin</span> 4
</div></div><div class="cell"><div class="code-block">logits <span class="symbol">:</span> <span class="type-name">Time</span> <span class="symbol">=&gt;</span> <span class="type-name">Vocab</span> <span class="symbol">=&gt;</span> <span class="type-name">Float</span> <span class="symbol">=</span> arb <span class="symbol">$</span> newKey 0
</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Create random labels
</span></div></div><div class="cell"><div class="code-block">labels <span class="symbol">=</span> <span class="keyword">for</span> i<span class="command">:position</span><span class="symbol">.</span> randIdxNoZero <span class="type-name">Vocab</span> (newKey (ordinal i))
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> labels
</div><div class="result-block">[(1@Fin 6), (5@Fin 6), (5@Fin 6)]</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Evaluate marginal probability of labels given logits
</span></div></div><div class="cell"><div class="code-block"><span class="command">:p</span> exp <span class="symbol">$</span> ctc blank logits labels
</div><div class="result-block">0.00104</div></div><div class="cell"><div class="code-block">


</div></div><div class="cell"><div class="prose-block"><h3>Test</h3>
</div></div><div class="cell"><div class="code-block"><span class="comment">-- Check that the sum of p(labels|logits) sums to 1.0 over all possible labels.
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- They don&#39;t yet sum to one, however I&#39;m not 100% sure about the
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- semantics of the marginal likelihood being computed, and whether
</span></div></div><div class="cell"><div class="code-block"><span class="comment">-- e.g. the summed-over labels should include blanks.
</span></div></div><div class="cell"><div class="code-block">

</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> sum <span class="keyword">for</span> i<span class="symbol">:</span><span class="type-name">Vocab</span><span class="symbol">.</span>
  exp <span class="symbol">$</span> ctc blank logits [i]
</div><div class="result-block">0.141468</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> sum <span class="keyword">for</span> (i<span class="symbol">,</span> j)<span class="symbol">:</span>(<span class="type-name">Vocab</span> <span class="symbol">&amp;</span> <span class="type-name">Vocab</span>)<span class="symbol">.</span>
  exp <span class="symbol">$</span> ctc blank logits [i<span class="symbol">,</span> j]
</div><div class="result-block">0.709123</div></div><div class="cell"><div class="code-block">
</div></div><div class="cell"><div class="code-block"><span class="command">:p</span> sum <span class="keyword">for</span> (i<span class="symbol">,</span> j<span class="symbol">,</span> k)<span class="symbol">:</span>(<span class="type-name">Vocab</span> <span class="symbol">&amp;</span> <span class="type-name">Vocab</span> <span class="symbol">&amp;</span> <span class="type-name">Vocab</span>)<span class="symbol">.</span>
  exp <span class="symbol">$</span> ctc blank logits [i<span class="symbol">,</span> j<span class="symbol">,</span> k]
</div><div class="result-block">0.925101</div></div></div></body></html>